# 第二章 信息的表示与处理

## 程序的可移植性

基本C数据类型的典型大小

![image-20210402144649791](note.assets/image-20210402144649791.png)

但是分配的字节数受程序是如何编译的影响而变化，为了避免依赖典型大小和不同编译带来的奇怪影响，ISO C99引入固定大小的数据类型：int32_t, int64_t 等相似数据类型，因此我们可以通过uint16_t来`无歧义的申明`一个16位无符号变量



## 补码

在许多场景中我们希望一个变量既可以表示正数也可以表示负数，所以最为常见的有符号数将会以补码的形式存放（而且许多数字默认是认为有符号数）。在这个定义中`将最高位解释为负权`，其他位按正常二进制权解释

![image-20210402145702994](note.assets/image-20210402145702994.png)

### 转换

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间 相互转换的一般规则是：`改变位的解释方式，不改变位模式`，当然不同字长的数据进行转换时就会扩展或截断位模式



## IEEE浮点表示

![image-20210402151326965](note.assets/image-20210402151326965.png)

使用该公式来表示一个浮点数

+   符号s：决定是正数还是负数
+   尾数M：是一个二进制小数
+   阶码E：对浮点数进行加权

将浮点数的位表示划分位三个字段，分别编码

![image-20210402151607503](note.assets/image-20210402151607503.png)



根据阶码的值被编码的值可以分成一下不同情况：

![image-20210402151735515](note.assets/image-20210402151735515.png)



# 第九章 虚拟内存

最开始CPU的寻址方式是物理寻址，这是CPU访问内存最自然的一种方式

![image-20210403095044467](note.assets/image-20210403095044467.png)

而现代CPU采用虚拟寻址的形式

![image-20210403095213645](note.assets/image-20210403095213645.png)

使用虚拟地址寻址离不开硬件和操作系统的配合，其中比较关键的是CPU利用一个虚拟地址(VA)来访问主存(当然CPU是不知道这是一个虚拟地址，它往死里用就完事了)，`VA经过MMU内存管理单元这个专用硬件通过放在主存中的查询表来动态翻译成物理地址(PA)`



## 虚拟内存作为缓冲工具

从概念上而言，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都由一个唯一的虚拟地址作为数组索引。

任意时刻虚拟页面都分为一下三种情况：

+   未分配的：VM系统还未分配(或创建)的页，未分配的块没有任何数据和他们相关联不占用任何磁盘空间
+   缓存的：当前以缓存在物理内存已分配的页
+   未缓存的：已分配但未缓存在物理内存中

![image-20210403150851528](note.assets/image-20210403150851528.png)



### 页表

每次地址硬件讲一个虚拟地址翻译成物理地址时都会读取页表。操作系统负责维护页表内容，以及在磁盘与内存间来回传送页

虚拟地址空间的每个页在页表中的一个固定偏移量处都有一个页表项PTE(Page Table Entry),PTE包含一个有效位来说明该虚拟页是否缓存在DRAM中

![image-20210403151719213](note.assets/image-20210403151719213.png)

### 缺页

当CPU引用也表中的一个虚拟页MMU发现该虚拟页没有缓存在物理内存中，这将引发一个缺页异常并调用内核中的缺页异常处理程序。缺页处理程序会从内存中选择一个牺牲页如果该页被修改了将其复制回磁盘。

![image-20210403152447166](note.assets/image-20210403152447166.png)

接下来将CPU要引用的虚拟页缓存到物理内存中

![image-20210403152523694](note.assets/image-20210403152523694.png)



## 虚拟内存作为内存管理工具

操作系统为每一个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。

![image-20210403152928471](note.assets/image-20210403152928471.png)

优点：

+   简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不需要管代码和数据实际存放在物理内存中的何处
+   简化加载：要把目标文件的.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，并标记为无效的(未缓存的)，将页表项指向目标文件中的适当位置即可。加载器不需要从磁盘到内存复制任何数据
+   简化共享
+   简化内存分配



## 虚拟内存作为内存保护的工具

每次CPU生成一个地址时，MMU会读到一个PTE，通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问

![image-20210403153848575](note.assets/image-20210403153848575.png)



## 地址翻译

![image-20210403154205512](note.assets/image-20210403154205512.png)

+   处理器生成一个虚拟地址，并传送给MMU
+   MMU生成PTE地址，并从高速缓存/主存中请求得到它
+   高速缓存/主存向MMU返回PTE
+   MMU构造物理地址，并传送给高速缓存/主存
    +   若PTE有效位是0则触发缺页异常，控制转给异常处理程序
    +   缺页处理程序确定牺牲页，若牺牲页已被修改则把它换出到磁盘
    +   缺页处理程序调入新页面，并更新内存中的PTE
    +   返回到原来导致缺页的指令
+   高速缓存/主存返回所请求的数据给处理器

![image-20210403155124576](note.assets/image-20210403155124576.png)



由于每次CPU产生一个虚拟地址都需要查找一个PTE，如果PTE没在高速缓存中而是内存将导耗时较长，为了消除这样的耗时甚至是在高速缓存中的时间花费，在MMU中包括一个关于PTE的小缓存：翻译后备缓冲器(TLB).

TLB是一个小的，虚拟寻址的缓存其每一行都保存着一个由单个PTE组成的块。 

![image-20210403155814526](note.assets/image-20210403155814526.png)

+   CPU产生一个虚拟地址
+   MMU从TLB取出对于PTE
+   MMU将这个虚拟地址翻译成物理地址。并发送到高速缓存/主存
+   请求的数据返回给CPU

当TLB不命中时，MMU从高速缓存/主存中取出相应PTE，新取出的PTE放入TLB，可能会覆盖一个已经存在的条目。

![image-20210403160236392](note.assets/image-20210403160236392.png)

